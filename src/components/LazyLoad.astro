---
export interface Props {
  threshold?: number;
  rootMargin?: string;
  once?: boolean;
  className?: string;
}

const {
  threshold = 0.1,
  rootMargin = '50px',
  once = true,
  className = ''
} = Astro.props;
---

<div 
  class={`lazy-container ${className}`}
  data-threshold={threshold}
  data-root-margin={rootMargin}
  data-once={once}
>
  <slot />
</div>

<style>
  .lazy-container {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }
  
  .lazy-container.loaded {
    opacity: 1;
    transform: translateY(0);
  }
  
  /* Animaciones específicas para diferentes elementos */
  .lazy-container[data-animation="fade-in"] {
    opacity: 0;
    transition: opacity 0.8s ease;
  }
  
  .lazy-container[data-animation="fade-in"].loaded {
    opacity: 1;
  }
  
  .lazy-container[data-animation="slide-up"] {
    opacity: 0;
    transform: translateY(30px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }
  
  .lazy-container[data-animation="slide-up"].loaded {
    opacity: 1;
    transform: translateY(0);
  }
  
  .lazy-container[data-animation="slide-left"] {
    opacity: 0;
    transform: translateX(-30px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }
  
  .lazy-container[data-animation="slide-left"].loaded {
    opacity: 1;
    transform: translateX(0);
  }
  
  .lazy-container[data-animation="slide-right"] {
    opacity: 0;
    transform: translateX(30px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }
  
  .lazy-container[data-animation="slide-right"].loaded {
    opacity: 1;
    transform: translateX(0);
  }
  
  .lazy-container[data-animation="scale"] {
    opacity: 0;
    transform: scale(0.9);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }
  
  .lazy-container[data-animation="scale"].loaded {
    opacity: 1;
    transform: scale(1);
  }
</style>

<script>
  class LazyLoader {
    private observer: IntersectionObserver;
    private containers: Set<Element> = new Set();

    constructor() {
      this.init();
    }

    private init() {
      // Crear observer con configuración por defecto
      this.observer = new IntersectionObserver(
        this.handleIntersection.bind(this),
        {
          threshold: 0.1,
          rootMargin: '50px'
        }
      );

      // Observar todos los contenedores lazy
      this.observeContainers();
      
      // Re-observar cuando se añaden nuevos elementos
      this.observeNewElements();
    }

    private observeContainers() {
      const containers = document.querySelectorAll('.lazy-container');
      containers.forEach(container => {
        this.observeContainer(container);
      });
    }

    private observeContainer(container: Element) {
      if (!this.containers.has(container)) {
        this.containers.add(container);
        
        // Configurar observer con parámetros específicos del contenedor
        const threshold = parseFloat(container.getAttribute('data-threshold') || '0.1');
        const rootMargin = container.getAttribute('data-root-margin') || '50px';
        
        const observer = new IntersectionObserver(
          this.handleIntersection.bind(this),
          { threshold, rootMargin }
        );
        
        observer.observe(container);
      }
    }

    private handleIntersection(entries: IntersectionObserverEntry[]) {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const container = entry.target as HTMLElement;
          this.loadContainer(container);
          
          // Si es "once", dejar de observar
          const once = container.getAttribute('data-once') === 'true';
          if (once) {
            this.observer.unobserve(container);
            this.containers.delete(container);
          }
        }
      });
    }

    private loadContainer(container: HTMLElement) {
      // Añadir clase loaded con delay para mejor animación
      setTimeout(() => {
        container.classList.add('loaded');
        
        // Disparar evento personalizado
        container.dispatchEvent(new CustomEvent('lazy-loaded', {
          detail: { container }
        }));
      }, 100);
    }

    private observeNewElements() {
      // Usar MutationObserver para detectar nuevos elementos
      const mutationObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node as Element;
              const lazyContainers = element.querySelectorAll('.lazy-container');
              lazyContainers.forEach(container => {
                this.observeContainer(container);
              });
            }
          });
        });
      });

      mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    }

    // Método público para añadir nuevos contenedores
    public addContainer(container: Element) {
      this.observeContainer(container);
    }

    // Método público para limpiar
    public destroy() {
      this.observer.disconnect();
      this.containers.clear();
    }
  }

  // Inicializar cuando el DOM esté listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new LazyLoader();
    });
  } else {
    new LazyLoader();
  }
</script>
