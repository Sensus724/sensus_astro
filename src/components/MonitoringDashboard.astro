---
// Componente de dashboard de monitoreo
---

<div class="monitoring-dashboard">
  <div class="dashboard-header">
    <h2>Dashboard de Monitoreo</h2>
    <div class="dashboard-controls">
      <button id="refresh-btn" class="btn btn-primary">Actualizar</button>
      <button id="export-btn" class="btn btn-secondary">Exportar</button>
    </div>
  </div>

  <div class="dashboard-grid">
    <!-- Métricas en tiempo real -->
    <div class="metric-card">
      <h3>Métricas en Tiempo Real</h3>
      <div class="metric-grid">
        <div class="metric-item">
          <span class="metric-label">Errores</span>
          <span class="metric-value" id="error-count">0</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Advertencias</span>
          <span class="metric-value" id="warn-count">0</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Sesiones Activas</span>
          <span class="metric-value" id="active-sessions">0</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Tiempo de Respuesta</span>
          <span class="metric-value" id="response-time">0ms</span>
        </div>
      </div>
    </div>

    <!-- Core Web Vitals -->
    <div class="metric-card">
      <h3>Core Web Vitals</h3>
      <div class="vitals-grid">
        <div class="vital-item">
          <span class="vital-label">LCP</span>
          <span class="vital-value" id="lcp-value">-</span>
          <span class="vital-status" id="lcp-status">-</span>
        </div>
        <div class="vital-item">
          <span class="vital-label">FID</span>
          <span class="vital-value" id="fid-value">-</span>
          <span class="vital-status" id="fid-status">-</span>
        </div>
        <div class="vital-item">
          <span class="vital-label">CLS</span>
          <span class="vital-value" id="cls-value">-</span>
          <span class="vital-status" id="cls-status">-</span>
        </div>
      </div>
    </div>

    <!-- Gráfico de logs -->
    <div class="metric-card chart-card">
      <h3>Logs por Nivel</h3>
      <canvas id="logs-chart" width="400" height="200"></canvas>
    </div>

    <!-- Gráfico de métricas -->
    <div class="metric-card chart-card">
      <h3>Métricas de Rendimiento</h3>
      <canvas id="metrics-chart" width="400" height="200"></canvas>
    </div>

    <!-- Alertas -->
    <div class="metric-card">
      <h3>Alertas Recientes</h3>
      <div class="alerts-list" id="alerts-list">
        <div class="alert-item">
          <span class="alert-time">-</span>
          <span class="alert-message">No hay alertas recientes</span>
          <span class="alert-severity">-</span>
        </div>
      </div>
    </div>

    <!-- Configuración -->
    <div class="metric-card">
      <h3>Configuración</h3>
      <div class="config-grid">
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-logging" checked>
            Habilitar Logging
          </label>
        </div>
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-metrics" checked>
            Habilitar Métricas
          </label>
        </div>
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-alerts" checked>
            Habilitar Alertas
          </label>
        </div>
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-performance" checked>
            Monitoreo de Rendimiento
          </label>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  import { getMonitoringService } from '../utils/monitoring';

  class MonitoringDashboard {
    private monitoringService: any;
    private charts: Map<string, any> = new Map();
    private updateInterval?: number;

    constructor() {
      this.monitoringService = getMonitoringService();
      this.init();
    }

    private init(): void {
      this.setupEventListeners();
      this.setupCharts();
      this.startRealTimeUpdates();
    }

    private setupEventListeners(): void {
      // Botón de actualizar
      document.getElementById('refresh-btn')?.addEventListener('click', () => {
        this.updateDashboard();
      });

      // Botón de exportar
      document.getElementById('export-btn')?.addEventListener('click', () => {
        this.exportData();
      });

      // Configuración
      document.getElementById('enable-logging')?.addEventListener('change', (e) => {
        this.toggleLogging((e.target as HTMLInputElement).checked);
      });

      document.getElementById('enable-metrics')?.addEventListener('change', (e) => {
        this.toggleMetrics((e.target as HTMLInputElement).checked);
      });

      document.getElementById('enable-alerts')?.addEventListener('change', (e) => {
        this.toggleAlerts((e.target as HTMLInputElement).checked);
      });

      document.getElementById('enable-performance')?.addEventListener('change', (e) => {
        this.togglePerformance((e.target as HTMLInputElement).checked);
      });
    }

    private setupCharts(): void {
      // Gráfico de logs
      const logsCanvas = document.getElementById('logs-chart') as HTMLCanvasElement;
      if (logsCanvas) {
        const logsChart = this.createLogsChart(logsCanvas);
        this.charts.set('logs', logsChart);
      }

      // Gráfico de métricas
      const metricsCanvas = document.getElementById('metrics-chart') as HTMLCanvasElement;
      if (metricsCanvas) {
        const metricsChart = this.createMetricsChart(metricsCanvas);
        this.charts.set('metrics', metricsChart);
      }
    }

    private createLogsChart(canvas: HTMLCanvasElement): any {
      const ctx = canvas.getContext('2d');
      if (!ctx) return null;

      return {
        canvas,
        ctx,
        data: {
          error: 0,
          warn: 0,
          info: 0,
          debug: 0,
        },
        update: (newData: any) => {
          this.data = { ...this.data, ...newData };
          this.drawLogsChart();
        },
        draw: () => {
          this.drawLogsChart();
        },
      };
    }

    private createMetricsChart(canvas: HTMLCanvasElement): any {
      const ctx = canvas.getContext('2d');
      if (!ctx) return null;

      return {
        canvas,
        ctx,
        data: {
          responseTime: [],
          memoryUsage: [],
          cpuUsage: [],
        },
        update: (newData: any) => {
          this.data = { ...this.data, ...newData };
          this.drawMetricsChart();
        },
        draw: () => {
          this.drawMetricsChart();
        },
      };
    }

    private drawLogsChart(): void {
      const chart = this.charts.get('logs');
      if (!chart) return;

      const { ctx, canvas, data } = chart;
      const width = canvas.width;
      const height = canvas.height;

      // Limpiar canvas
      ctx.clearRect(0, 0, width, height);

      // Configurar colores
      const colors = {
        error: '#ff4444',
        warn: '#ffaa00',
        info: '#4488ff',
        debug: '#888888',
      };

      // Calcular total
      const total = Object.values(data).reduce((sum: number, value: any) => sum + value, 0);
      if (total === 0) return;

      // Dibujar gráfico de barras
      let x = 0;
      const barWidth = width / 4;
      const maxHeight = height - 40;

      Object.entries(data).forEach(([level, value]) => {
        const barHeight = (value / total) * maxHeight;
        const y = height - barHeight - 20;

        // Dibujar barra
        ctx.fillStyle = colors[level as keyof typeof colors];
        ctx.fillRect(x, y, barWidth - 10, barHeight);

        // Dibujar etiqueta
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(level, x + barWidth / 2, height - 5);
        ctx.fillText(value.toString(), x + barWidth / 2, y - 5);

        x += barWidth;
      });
    }

    private drawMetricsChart(): void {
      const chart = this.charts.get('metrics');
      if (!chart) return;

      const { ctx, canvas, data } = chart;
      const width = canvas.width;
      const height = canvas.height;

      // Limpiar canvas
      ctx.clearRect(0, 0, width, height);

      // Dibujar gráfico de líneas para tiempo de respuesta
      if (data.responseTime.length > 0) {
        ctx.strokeStyle = '#4488ff';
        ctx.lineWidth = 2;
        ctx.beginPath();

        data.responseTime.forEach((value: number, index: number) => {
          const x = (index / (data.responseTime.length - 1)) * width;
          const y = height - (value / 1000) * height; // Normalizar a 1000ms

          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });

        ctx.stroke();
      }

      // Dibujar gráfico de líneas para uso de memoria
      if (data.memoryUsage.length > 0) {
        ctx.strokeStyle = '#ff4444';
        ctx.lineWidth = 2;
        ctx.beginPath();

        data.memoryUsage.forEach((value: number, index: number) => {
          const x = (index / (data.memoryUsage.length - 1)) * width;
          const y = height - (value / 100000000) * height; // Normalizar a 100MB

          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });

        ctx.stroke();
      }
    }

    private startRealTimeUpdates(): void {
      this.updateInterval = setInterval(() => {
        this.updateDashboard();
      }, 5000); // Actualizar cada 5 segundos
    }

    private async updateDashboard(): Promise<void> {
      try {
        // Actualizar métricas en tiempo real
        await this.updateRealTimeMetrics();

        // Actualizar Core Web Vitals
        await this.updateCoreWebVitals();

        // Actualizar gráficos
        this.updateCharts();

        // Actualizar alertas
        await this.updateAlerts();
      } catch (error) {
        console.error('Error updating dashboard:', error);
      }
    }

    private async updateRealTimeMetrics(): Promise<void> {
      // Simular datos de métricas
      const errorCount = Math.floor(Math.random() * 10);
      const warnCount = Math.floor(Math.random() * 20);
      const activeSessions = Math.floor(Math.random() * 100) + 50;
      const responseTime = Math.floor(Math.random() * 500) + 100;

      // Actualizar UI
      this.updateElement('error-count', errorCount.toString());
      this.updateElement('warn-count', warnCount.toString());
      this.updateElement('active-sessions', activeSessions.toString());
      this.updateElement('response-time', `${responseTime}ms`);
    }

    private async updateCoreWebVitals(): Promise<void> {
      // Simular datos de Core Web Vitals
      const lcp = Math.floor(Math.random() * 3000) + 1000;
      const fid = Math.floor(Math.random() * 200) + 50;
      const cls = Math.random() * 0.3;

      // Actualizar UI
      this.updateElement('lcp-value', `${lcp}ms`);
      this.updateElement('fid-value', `${fid}ms`);
      this.updateElement('cls-value', cls.toFixed(3));

      // Actualizar estados
      this.updateElement('lcp-status', this.getVitalStatus(lcp, 2500, 4000));
      this.updateElement('fid-status', this.getVitalStatus(fid, 100, 300));
      this.updateElement('cls-status', this.getVitalStatus(cls, 0.1, 0.25));
    }

    private getVitalStatus(value: number, good: number, poor: number): string {
      if (value <= good) return '✅ Bueno';
      if (value <= poor) return '⚠️ Necesita Mejora';
      return '❌ Pobre';
    }

    private updateCharts(): void {
      // Actualizar gráfico de logs
      const logsChart = this.charts.get('logs');
      if (logsChart) {
        logsChart.update({
          error: Math.floor(Math.random() * 10),
          warn: Math.floor(Math.random() * 20),
          info: Math.floor(Math.random() * 50),
          debug: Math.floor(Math.random() * 100),
        });
      }

      // Actualizar gráfico de métricas
      const metricsChart = this.charts.get('metrics');
      if (metricsChart) {
        const now = Date.now();
        metricsChart.update({
          responseTime: [...(metricsChart.data.responseTime || []), Math.floor(Math.random() * 500) + 100].slice(-20),
          memoryUsage: [...(metricsChart.data.memoryUsage || []), Math.floor(Math.random() * 100000000) + 50000000].slice(-20),
        });
      }
    }

    private async updateAlerts(): Promise<void> {
      // Simular alertas
      const alerts = [
        {
          time: new Date().toLocaleTimeString(),
          message: 'Tasa de error alta detectada',
          severity: 'high',
        },
        {
          time: new Date(Date.now() - 300000).toLocaleTimeString(),
          message: 'Tiempo de respuesta lento',
          severity: 'medium',
        },
      ];

      const alertsList = document.getElementById('alerts-list');
      if (alertsList) {
        alertsList.innerHTML = alerts.map(alert => `
          <div class="alert-item">
            <span class="alert-time">${alert.time}</span>
            <span class="alert-message">${alert.message}</span>
            <span class="alert-severity ${alert.severity}">${alert.severity}</span>
          </div>
        `).join('');
      }
    }

    private updateElement(id: string, value: string): void {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = value;
      }
    }

    private toggleLogging(enabled: boolean): void {
      // Implementar toggle de logging
      console.log('Logging toggled:', enabled);
    }

    private toggleMetrics(enabled: boolean): void {
      // Implementar toggle de métricas
      console.log('Metrics toggled:', enabled);
    }

    private toggleAlerts(enabled: boolean): void {
      // Implementar toggle de alertas
      console.log('Alerts toggled:', enabled);
    }

    private togglePerformance(enabled: boolean): void {
      // Implementar toggle de rendimiento
      console.log('Performance monitoring toggled:', enabled);
    }

    private async exportData(): Promise<void> {
      try {
        // Exportar datos de monitoreo
        const data = {
          timestamp: new Date().toISOString(),
          metrics: {
            errorCount: document.getElementById('error-count')?.textContent,
            warnCount: document.getElementById('warn-count')?.textContent,
            activeSessions: document.getElementById('active-sessions')?.textContent,
            responseTime: document.getElementById('response-time')?.textContent,
          },
          vitals: {
            lcp: document.getElementById('lcp-value')?.textContent,
            fid: document.getElementById('fid-value')?.textContent,
            cls: document.getElementById('cls-value')?.textContent,
          },
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `monitoring-data-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Error exporting data:', error);
      }
    }

    public destroy(): void {
      if (this.updateInterval) {
        clearInterval(this.updateInterval);
      }
    }
  }

  // Inicializar dashboard cuando el DOM esté listo
  document.addEventListener('DOMContentLoaded', () => {
    new MonitoringDashboard();
  });
</script>

<style>
  .monitoring-dashboard {
    padding: 2rem;
    max-width: 1200px;
    margin: 0 auto;
  }

  .dashboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
  }

  .dashboard-controls {
    display: flex;
    gap: 1rem;
  }

  .dashboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
  }

  .metric-card {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    padding: 1.5rem;
    box-shadow: var(--shadow-sm);
  }

  .metric-card h3 {
    margin: 0 0 1rem 0;
    color: var(--color-text-primary);
  }

  .metric-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
  }

  .metric-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
    background: var(--color-surface-secondary);
    border-radius: var(--border-radius);
  }

  .metric-label {
    font-size: 0.875rem;
    color: var(--color-text-secondary);
    margin-bottom: 0.5rem;
  }

  .metric-value {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--color-text-primary);
  }

  .vitals-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
  }

  .vital-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
    background: var(--color-surface-secondary);
    border-radius: var(--border-radius);
  }

  .vital-label {
    font-size: 0.875rem;
    color: var(--color-text-secondary);
    margin-bottom: 0.5rem;
  }

  .vital-value {
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--color-text-primary);
    margin-bottom: 0.5rem;
  }

  .vital-status {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: var(--border-radius);
    background: var(--color-success);
    color: white;
  }

  .chart-card {
    grid-column: span 2;
  }

  .alerts-list {
    max-height: 200px;
    overflow-y: auto;
  }

  .alert-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    background: var(--color-surface-secondary);
    border-radius: var(--border-radius);
    border-left: 4px solid var(--color-warning);
  }

  .alert-time {
    font-size: 0.75rem;
    color: var(--color-text-secondary);
  }

  .alert-message {
    flex: 1;
    margin: 0 1rem;
    color: var(--color-text-primary);
  }

  .alert-severity {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: var(--border-radius);
    color: white;
  }

  .alert-severity.high {
    background: var(--color-error);
  }

  .alert-severity.medium {
    background: var(--color-warning);
  }

  .alert-severity.low {
    background: var(--color-info);
  }

  .config-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
  }

  .config-item {
    display: flex;
    align-items: center;
  }

  .config-item label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    color: var(--color-text-primary);
  }

  .config-item input[type="checkbox"] {
    width: 1rem;
    height: 1rem;
  }

  @media (max-width: 768px) {
    .dashboard-grid {
      grid-template-columns: 1fr;
    }

    .chart-card {
      grid-column: span 1;
    }

    .metric-grid,
    .vitals-grid,
    .config-grid {
      grid-template-columns: 1fr;
    }
  }
</style>
