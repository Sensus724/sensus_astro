---
export interface Props {
  src: string
  alt: string
  width?: number
  height?: number
  loading?: 'lazy' | 'eager'
  priority?: boolean
  quality?: number
  format?: 'webp' | 'avif' | 'auto'
  sizes?: string
  class?: string
  placeholder?: 'blur' | 'empty'
  blurDataURL?: string
}

const {
  src,
  alt,
  width,
  height,
  loading = 'lazy',
  priority = false,
  quality = 80,
  format = 'auto',
  sizes = '100vw',
  class: className = '',
  placeholder = 'blur',
  blurDataURL
} = Astro.props

// Generar srcset para diferentes tamaños
const generateSrcSet = (baseSrc: string, format: string) => {
  const sizes = [320, 640, 768, 1024, 1280, 1920]
  return sizes
    .map(size => `${baseSrc}?w=${size}&q=${quality}&f=${format} ${size}w`)
    .join(', ')
}

// Generar diferentes formatos
const generateFormats = (baseSrc: string) => {
  const formats = format === 'auto' ? ['webp', 'avif'] : [format]
  return formats.map(fmt => ({
    format: fmt,
    srcset: generateSrcSet(baseSrc, fmt)
  }))
}

const formats = generateFormats(src)
const primaryFormat = formats[0]
---

<picture class={`optimized-image ${className}`}>
  {formats.map(({ format, srcset }) => (
    <source 
      srcset={srcset}
      type={`image/${format}`}
      sizes={sizes}
    />
  ))}
  
  <img
    src={src}
    alt={alt}
    width={width}
    height={height}
    loading={priority ? 'eager' : loading}
    decoding={priority ? 'sync' : 'async'}
    class={`optimized-image-img ${className}`}
    style={{
      aspectRatio: width && height ? `${width}/${height}` : undefined
    }}
    {...(placeholder === 'blur' && blurDataURL && {
      style: `background-image: url(${blurDataURL}); background-size: cover; background-position: center;`
    })}
  />
</picture>

<style>
  .optimized-image {
    display: block;
    position: relative;
    overflow: hidden;
  }

  .optimized-image-img {
    width: 100%;
    height: auto;
    display: block;
    transition: opacity 0.3s ease;
  }

  .optimized-image-img[loading="lazy"] {
    opacity: 0;
  }

  .optimized-image-img[loading="lazy"].loaded {
    opacity: 1;
  }

  /* Placeholder blur */
  .optimized-image-img[style*="background-image"] {
    filter: blur(5px);
    transform: scale(1.1);
  }

  .optimized-image-img[style*="background-image"].loaded {
    filter: none;
    transform: scale(1);
  }

  /* Aspect ratio container */
  .optimized-image[style*="aspect-ratio"] {
    position: relative;
  }

  .optimized-image[style*="aspect-ratio"] .optimized-image-img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Loading animation */
  .optimized-image.loading::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    z-index: 1;
  }

  @keyframes loading {
    0% {
      background-position: 200% 0;
    }
    100% {
      background-position: -200% 0;
    }
  }

  /* Error state */
  .optimized-image.error .optimized-image-img {
    display: none;
  }

  .optimized-image.error::after {
    content: 'Imagen no disponible';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--color-text-secondary, #64748b);
    font-size: 14px;
    text-align: center;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .optimized-image-img {
      max-width: 100%;
      height: auto;
    }
  }

  /* Tema oscuro */
  [data-theme="dark"] .optimized-image.loading::before {
    background: linear-gradient(90deg, #2a2a2a 25%, #3a3a3a 50%, #2a2a2a 75%);
  }

  [data-theme="dark"] .optimized-image.error::after {
    color: var(--color-text-secondary, #94a3b8);
  }
</style>

<script>
  // Lazy loading y optimización
  document.addEventListener('DOMContentLoaded', function() {
    const images = document.querySelectorAll('.optimized-image-img[loading="lazy"]');
    
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            
            // Cargar imagen
            img.addEventListener('load', () => {
              img.classList.add('loaded');
              img.closest('.optimized-image')?.classList.remove('loading');
            });
            
            img.addEventListener('error', () => {
              img.closest('.optimized-image')?.classList.add('error');
            });
            
            observer.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px'
      });
      
      images.forEach(img => imageObserver.observe(img));
    } else {
      // Fallback para navegadores sin IntersectionObserver
      images.forEach(img => {
        img.addEventListener('load', () => {
          img.classList.add('loaded');
          img.closest('.optimized-image')?.classList.remove('loading');
        });
      });
    }
  });
</script>