---
export interface Props {
  class?: string;
  showDetails?: boolean;
}

const {
  class: className = '',
  showDetails = false,
  ...rest
} = Astro.props;

const classes = [
  'pwa-status',
  className
].filter(Boolean).join(' ');
---

<div class={classes} {...rest}>
  <div class="pwa-status-indicator" id="pwa-status-indicator">
    <div class="pwa-status-icon">
      <i class="fas fa-mobile-alt"></i>
    </div>
    <div class="pwa-status-text">
      <span class="pwa-status-label">Estado PWA</span>
      <span class="pwa-status-value" id="pwa-status-value">Verificando...</span>
    </div>
  </div>

  {showDetails && (
    <div class="pwa-status-details" id="pwa-status-details">
      <div class="pwa-detail-item">
        <span class="pwa-detail-label">Instalada:</span>
        <span class="pwa-detail-value" id="pwa-installed-status">-</span>
      </div>
      <div class="pwa-detail-item">
        <span class="pwa-detail-label">Service Worker:</span>
        <span class="pwa-detail-value" id="pwa-sw-status">-</span>
      </div>
      <div class="pwa-detail-item">
        <span class="pwa-detail-label">Conexión:</span>
        <span class="pwa-detail-value" id="pwa-connection-status">-</span>
      </div>
      <div class="pwa-detail-item">
        <span class="pwa-detail-label">Caché:</span>
        <span class="pwa-detail-value" id="pwa-cache-status">-</span>
      </div>
      <div class="pwa-detail-item">
        <span class="pwa-detail-label">Actualizaciones:</span>
        <span class="pwa-detail-value" id="pwa-update-status">-</span>
      </div>
    </div>
  )}
</div>

<style>
  .pwa-status {
    @apply bg-white rounded-lg border border-gray-200 p-4 shadow-sm;
  }

  .pwa-status-indicator {
    @apply flex items-center gap-3;
  }

  .pwa-status-icon {
    @apply w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center;
    @apply text-blue-600;
  }

  .pwa-status-text {
    @apply flex-1;
  }

  .pwa-status-label {
    @apply block text-sm font-medium text-gray-700;
  }

  .pwa-status-value {
    @apply block text-sm text-gray-900 font-semibold;
  }

  .pwa-status-details {
    @apply mt-4 pt-4 border-t border-gray-200 space-y-2;
  }

  .pwa-detail-item {
    @apply flex justify-between items-center text-sm;
  }

  .pwa-detail-label {
    @apply text-gray-600;
  }

  .pwa-detail-value {
    @apply font-medium;
  }

  /* Estados de estado */
  .pwa-status-value.installed {
    @apply text-green-600;
  }

  .pwa-status-value.not-installed {
    @apply text-orange-600;
  }

  .pwa-status-value.error {
    @apply text-red-600;
  }

  .pwa-status-value.online {
    @apply text-green-600;
  }

  .pwa-status-value.offline {
    @apply text-red-600;
  }

  .pwa-status-value.active {
    @apply text-green-600;
  }

  .pwa-status-value.inactive {
    @apply text-gray-600;
  }

  .pwa-status-value.available {
    @apply text-blue-600;
  }

  .pwa-status-value.unavailable {
    @apply text-gray-600;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .pwa-status {
      @apply p-3;
    }
    
    .pwa-status-indicator {
      @apply gap-2;
    }
    
    .pwa-status-icon {
      @apply w-6 h-6;
    }
    
    .pwa-status-text {
      @apply text-xs;
    }
  }
</style>

<script>
  class PWAStatus {
    constructor() {
      this.statusElement = document.getElementById('pwa-status-value');
      this.detailsElement = document.getElementById('pwa-status-details');
      
      this.init();
    }
    
    async init() {
      await this.checkPWAStatus();
      this.setupEventListeners();
    }
    
    async checkPWAStatus() {
      try {
        // Verificar si está instalada
        const isInstalled = this.checkIfInstalled();
        this.updateStatus('installed', isInstalled ? 'Instalada' : 'No instalada');
        this.updateDetail('pwa-installed-status', isInstalled ? 'Sí' : 'No');
        
        // Verificar Service Worker
        const swInfo = await this.getServiceWorkerInfo();
        this.updateStatus('sw', swInfo ? 'Activo' : 'Inactivo');
        this.updateDetail('pwa-sw-status', swInfo ? 'Activo' : 'Inactivo');
        
        // Verificar conexión
        const isOnline = navigator.onLine;
        this.updateStatus('connection', isOnline ? 'En línea' : 'Sin conexión');
        this.updateDetail('pwa-connection-status', isOnline ? 'En línea' : 'Sin conexión');
        
        // Verificar caché
        const cacheSize = await this.getCacheSize();
        this.updateStatus('cache', cacheSize > 0 ? 'Disponible' : 'No disponible');
        this.updateDetail('pwa-cache-status', cacheSize > 0 ? `${this.formatBytes(cacheSize)}` : 'No disponible');
        
        // Verificar actualizaciones
        const updateAvailable = swInfo?.updateAvailable || false;
        this.updateStatus('update', updateAvailable ? 'Disponible' : 'Actualizado');
        this.updateDetail('pwa-update-status', updateAvailable ? 'Disponible' : 'Actualizado');
        
      } catch (error) {
        console.error('Error checking PWA status:', error);
        this.updateStatus('error', 'Error');
      }
    }
    
    checkIfInstalled() {
      return window.matchMedia('(display-mode: standalone)').matches ||
             window.navigator.standalone === true ||
             document.referrer.includes('android-app://');
    }
    
    async getServiceWorkerInfo() {
      if (!('serviceWorker' in navigator)) return null;
      
      try {
        const registration = await navigator.serviceWorker.getRegistration();
        return registration ? {
          scope: registration.scope,
          state: registration.active?.state || 'unknown',
          updateAvailable: registration.waiting !== null,
        } : null;
      } catch (error) {
        console.error('Error getting Service Worker info:', error);
        return null;
      }
    }
    
    async getCacheSize() {
      if (!('caches' in window)) return 0;
      
      try {
        const cacheNames = await caches.keys();
        let totalSize = 0;
        
        for (const cacheName of cacheNames) {
          const cache = await caches.open(cacheName);
          const keys = await cache.keys();
          
          for (const request of keys) {
            const response = await cache.match(request);
            if (response) {
              const blob = await response.blob();
              totalSize += blob.size;
            }
          }
        }
        
        return totalSize;
      } catch (error) {
        console.error('Error getting cache size:', error);
        return 0;
      }
    }
    
    formatBytes(bytes) {
      if (bytes === 0) return '0 Bytes';
      
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    updateStatus(type, value) {
      if (this.statusElement) {
        this.statusElement.textContent = value;
        this.statusElement.className = `block text-sm text-gray-900 font-semibold ${type}`;
      }
    }
    
    updateDetail(elementId, value) {
      const element = document.getElementById(elementId);
      if (element) {
        element.textContent = value;
      }
    }
    
    setupEventListeners() {
      // Escuchar cambios de conectividad
      window.addEventListener('online', () => {
        this.updateStatus('connection', 'En línea');
        this.updateDetail('pwa-connection-status', 'En línea');
      });
      
      window.addEventListener('offline', () => {
        this.updateStatus('connection', 'Sin conexión');
        this.updateDetail('pwa-connection-status', 'Sin conexión');
      });
      
      // Escuchar cambios del Service Worker
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          this.checkPWAStatus();
        });
      }
    }
  }
  
  // Inicializar cuando el DOM esté listo
  document.addEventListener('DOMContentLoaded', () => {
    new PWAStatus();
  });
</script>
