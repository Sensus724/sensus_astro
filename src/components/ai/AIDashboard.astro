---
// Dashboard de IA y Machine Learning para Sensus
---

<div class="ai-dashboard">
  <div class="dashboard-header">
    <h2>Dashboard de IA y Machine Learning</h2>
    <div class="dashboard-controls">
      <button id="refresh-ai-btn" class="btn btn-primary">Actualizar</button>
      <button id="export-ai-btn" class="btn btn-secondary">Exportar</button>
      <button id="ai-settings-btn" class="btn btn-outline">Configuración</button>
    </div>
  </div>

  <div class="dashboard-grid">
    <!-- Modelos de ML -->
    <div class="metric-card">
      <h3>Modelos de Machine Learning</h3>
      <div class="models-list" id="ml-models">
        <div class="model-item">
          <span class="model-name">-</span>
          <span class="model-status">-</span>
          <span class="model-accuracy">-</span>
        </div>
      </div>
    </div>

    <!-- Predicciones -->
    <div class="metric-card">
      <h3>Predicciones Recientes</h3>
      <div class="predictions-list" id="recent-predictions">
        <div class="prediction-item">
          <span class="prediction-model">-</span>
          <span class="prediction-result">-</span>
          <span class="prediction-confidence">-</span>
        </div>
      </div>
    </div>

    <!-- Recomendaciones -->
    <div class="metric-card">
      <h3>Recomendaciones Activas</h3>
      <div class="recommendations-list" id="active-recommendations">
        <div class="recommendation-item">
          <span class="recommendation-type">-</span>
          <span class="recommendation-item">-</span>
          <span class="recommendation-score">-</span>
        </div>
      </div>
    </div>

    <!-- Detección de Anomalías -->
    <div class="metric-card">
      <h3>Detección de Anomalías</h3>
      <div class="anomalies-list" id="recent-anomalies">
        <div class="anomaly-item">
          <span class="anomaly-type">-</span>
          <span class="anomaly-severity">-</span>
          <span class="anomaly-status">-</span>
        </div>
      </div>
    </div>

    <!-- Segmentación de Usuarios -->
    <div class="metric-card">
      <h3>Segmentación de Usuarios</h3>
      <div class="segments-list" id="user-segments">
        <div class="segment-item">
          <span class="segment-name">-</span>
          <span class="segment-size">-</span>
          <span class="segment-percentage">-</span>
        </div>
      </div>
    </div>

    <!-- Análisis de Sentimiento -->
    <div class="metric-card">
      <h3>Análisis de Sentimiento</h3>
      <div class="sentiment-summary">
        <div class="sentiment-item">
          <span class="sentiment-label">Positivo</span>
          <span class="sentiment-percentage" id="positive-sentiment">0%</span>
        </div>
        <div class="sentiment-item">
          <span class="sentiment-label">Neutral</span>
          <span class="sentiment-percentage" id="neutral-sentiment">0%</span>
        </div>
        <div class="sentiment-item">
          <span class="sentiment-label">Negativo</span>
          <span class="sentiment-percentage" id="negative-sentiment">0%</span>
        </div>
      </div>
    </div>

    <!-- Predicción de Churn -->
    <div class="metric-card">
      <h3>Predicción de Churn</h3>
      <div class="churn-summary">
        <div class="churn-item">
          <span class="churn-label">Riesgo Bajo</span>
          <span class="churn-count" id="low-risk">0</span>
        </div>
        <div class="churn-item">
          <span class="churn-label">Riesgo Medio</span>
          <span class="churn-count" id="medium-risk">0</span>
        </div>
        <div class="churn-item">
          <span class="churn-label">Riesgo Alto</span>
          <span class="churn-count" id="high-risk">0</span>
        </div>
        <div class="churn-item">
          <span class="churn-label">Riesgo Crítico</span>
          <span class="churn-count" id="critical-risk">0</span>
        </div>
      </div>
    </div>

    <!-- Gráfico de rendimiento de modelos -->
    <div class="metric-card chart-card">
      <h3>Rendimiento de Modelos</h3>
      <canvas id="model-performance-chart" width="400" height="200"></canvas>
    </div>

    <!-- Gráfico de predicciones -->
    <div class="metric-card chart-card">
      <h3>Predicciones por Día</h3>
      <canvas id="predictions-chart" width="400" height="200"></canvas>
    </div>

    <!-- Configuración de IA -->
    <div class="metric-card">
      <h3>Configuración de IA</h3>
      <div class="ai-config">
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-auto-training" checked>
            Entrenamiento Automático
          </label>
        </div>
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-realtime-predictions" checked>
            Predicciones en Tiempo Real
          </label>
        </div>
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-recommendations" checked>
            Sistema de Recomendaciones
          </label>
        </div>
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-anomaly-detection" checked>
            Detección de Anomalías
          </label>
        </div>
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-sentiment-analysis" checked>
            Análisis de Sentimiento
          </label>
        </div>
        <div class="config-item">
          <label>
            <input type="checkbox" id="enable-churn-prediction" checked>
            Predicción de Churn
          </label>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  import { machineLearning } from '../../utils/machineLearning';

  class AIDashboard {
    private charts: Map<string, any> = new Map();
    private updateInterval?: number;

    constructor() {
      this.init();
    }

    private init(): void {
      this.setupEventListeners();
      this.setupCharts();
      this.startRealTimeUpdates();
    }

    private setupEventListeners(): void {
      // Botón de actualizar
      document.getElementById('refresh-ai-btn')?.addEventListener('click', () => {
        this.updateDashboard();
      });

      // Botón de exportar
      document.getElementById('export-ai-btn')?.addEventListener('click', () => {
        this.exportAIData();
      });

      // Botón de configuración
      document.getElementById('ai-settings-btn')?.addEventListener('click', () => {
        this.openAISettings();
      });

      // Configuración de IA
      document.getElementById('enable-auto-training')?.addEventListener('change', (e) => {
        this.toggleAutoTraining((e.target as HTMLInputElement).checked);
      });

      document.getElementById('enable-realtime-predictions')?.addEventListener('change', (e) => {
        this.toggleRealtimePredictions((e.target as HTMLInputElement).checked);
      });

      document.getElementById('enable-recommendations')?.addEventListener('change', (e) => {
        this.toggleRecommendations((e.target as HTMLInputElement).checked);
      });

      document.getElementById('enable-anomaly-detection')?.addEventListener('change', (e) => {
        this.toggleAnomalyDetection((e.target as HTMLInputElement).checked);
      });

      document.getElementById('enable-sentiment-analysis')?.addEventListener('change', (e) => {
        this.toggleSentimentAnalysis((e.target as HTMLInputElement).checked);
      });

      document.getElementById('enable-churn-prediction')?.addEventListener('change', (e) => {
        this.toggleChurnPrediction((e.target as HTMLInputElement).checked);
      });
    }

    private setupCharts(): void {
      // Gráfico de rendimiento de modelos
      const modelPerformanceCanvas = document.getElementById('model-performance-chart') as HTMLCanvasElement;
      if (modelPerformanceCanvas) {
        const modelPerformanceChart = this.createModelPerformanceChart(modelPerformanceCanvas);
        this.charts.set('modelPerformance', modelPerformanceChart);
      }

      // Gráfico de predicciones
      const predictionsCanvas = document.getElementById('predictions-chart') as HTMLCanvasElement;
      if (predictionsCanvas) {
        const predictionsChart = this.createPredictionsChart(predictionsCanvas);
        this.charts.set('predictions', predictionsChart);
      }
    }

    private createModelPerformanceChart(canvas: HTMLCanvasElement): any {
      const ctx = canvas.getContext('2d');
      if (!ctx) return null;

      return {
        canvas,
        ctx,
        data: {
          labels: ['Accuracy', 'Precision', 'Recall', 'F1-Score'],
          datasets: [{
            label: 'Model Performance',
            data: [0.85, 0.82, 0.78, 0.80],
            backgroundColor: ['#4488ff', '#00aa00', '#ffaa00', '#ff4444'],
            borderWidth: 2,
            borderColor: '#fff',
          }],
        },
        update: (newData: any) => {
          this.data = { ...this.data, ...newData };
          this.drawModelPerformanceChart();
        },
        draw: () => {
          this.drawModelPerformanceChart();
        },
      };
    }

    private createPredictionsChart(canvas: HTMLCanvasElement): any {
      const ctx = canvas.getContext('2d');
      if (!ctx) return null;

      return {
        canvas,
        ctx,
        data: {
          labels: Array.from({ length: 7 }, (_, i) => {
            const date = new Date();
            date.setDate(date.getDate() - (6 - i));
            return date.toLocaleDateString();
          }),
          datasets: [{
            label: 'Predictions',
            data: Array.from({ length: 7 }, () => Math.floor(Math.random() * 1000) + 500),
            borderColor: '#4488ff',
            backgroundColor: 'rgba(68, 136, 255, 0.1)',
            fill: true,
          }],
        },
        update: (newData: any) => {
          this.data = { ...this.data, ...newData };
          this.drawPredictionsChart();
        },
        draw: () => {
          this.drawPredictionsChart();
        },
      };
    }

    private drawModelPerformanceChart(): void {
      const chart = this.charts.get('modelPerformance');
      if (!chart) return;

      const { ctx, canvas, data } = chart;
      const width = canvas.width;
      const height = canvas.height;

      // Limpiar canvas
      ctx.clearRect(0, 0, width, height);

      // Dibujar gráfico de barras
      const barWidth = width / data.labels.length;
      const maxValue = Math.max(...data.datasets[0].data);

      data.labels.forEach((label: string, index: number) => {
        const barHeight = (data.datasets[0].data[index] / maxValue) * height;
        const x = index * barWidth;
        const y = height - barHeight;

        ctx.fillStyle = data.datasets[0].backgroundColor[index];
        ctx.fillRect(x, y, barWidth - 10, barHeight);

        // Dibujar etiqueta
        ctx.fillStyle = '#333';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(label, x + barWidth / 2, height - 5);
        ctx.fillText((data.datasets[0].data[index] * 100).toFixed(1) + '%', x + barWidth / 2, y - 5);
      });
    }

    private drawPredictionsChart(): void {
      const chart = this.charts.get('predictions');
      if (!chart) return;

      const { ctx, canvas, data } = chart;
      const width = canvas.width;
      const height = canvas.height;

      // Limpiar canvas
      ctx.clearRect(0, 0, width, height);

      // Dibujar gráfico de líneas
      ctx.strokeStyle = data.datasets[0].borderColor;
      ctx.lineWidth = 2;
      ctx.beginPath();

      data.labels.forEach((label: string, index: number) => {
        const x = (index / (data.labels.length - 1)) * width;
        const y = height - (data.datasets[0].data[index] / Math.max(...data.datasets[0].data)) * height;

        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      ctx.stroke();

      // Dibujar puntos
      ctx.fillStyle = data.datasets[0].borderColor;
      data.labels.forEach((label: string, index: number) => {
        const x = (index / (data.labels.length - 1)) * width;
        const y = height - (data.datasets[0].data[index] / Math.max(...data.datasets[0].data)) * height;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, 2 * Math.PI);
        ctx.fill();
      });
    }

    private startRealTimeUpdates(): void {
      this.updateInterval = setInterval(() => {
        this.updateDashboard();
      }, 30000); // Actualizar cada 30 segundos
    }

    private async updateDashboard(): Promise<void> {
      try {
        // Actualizar modelos de ML
        await this.updateMLModels();

        // Actualizar predicciones
        await this.updatePredictions();

        // Actualizar recomendaciones
        await this.updateRecommendations();

        // Actualizar anomalías
        await this.updateAnomalies();

        // Actualizar segmentación
        await this.updateUserSegmentation();

        // Actualizar análisis de sentimiento
        await this.updateSentimentAnalysis();

        // Actualizar predicción de churn
        await this.updateChurnPrediction();

        // Actualizar gráficos
        this.updateCharts();
      } catch (error) {
        console.error('Error updating AI dashboard:', error);
      }
    }

    private async updateMLModels(): Promise<void> {
      const models = machineLearning.getModels();

      const modelsList = document.getElementById('ml-models');
      if (modelsList) {
        if (models.length === 0) {
          modelsList.innerHTML = `
            <div class="model-item">
              <span class="model-name">-</span>
              <span class="model-status">-</span>
              <span class="model-accuracy">-</span>
            </div>
          `;
        } else {
          modelsList.innerHTML = models.slice(0, 5).map(model => `
            <div class="model-item">
              <span class="model-name">${model.name}</span>
              <span class="model-status ${model.status}">${model.status}</span>
              <span class="model-accuracy">${model.accuracy ? (model.accuracy * 100).toFixed(1) + '%' : 'N/A'}</span>
            </div>
          `).join('');
        }
      }
    }

    private async updatePredictions(): Promise<void> {
      const predictions = machineLearning.getPredictions();

      const predictionsList = document.getElementById('recent-predictions');
      if (predictionsList) {
        if (predictions.length === 0) {
          predictionsList.innerHTML = `
            <div class="prediction-item">
              <span class="prediction-model">-</span>
              <span class="prediction-result">-</span>
              <span class="prediction-confidence">-</span>
            </div>
          `;
        } else {
          predictionsList.innerHTML = predictions.slice(-5).reverse().map(prediction => `
            <div class="prediction-item">
              <span class="prediction-model">${prediction.modelId}</span>
              <span class="prediction-result">${JSON.stringify(prediction.output).substring(0, 20)}...</span>
              <span class="prediction-confidence">${(prediction.confidence * 100).toFixed(1)}%</span>
            </div>
          `).join('');
        }
      }
    }

    private async updateRecommendations(): Promise<void> {
      const recommendations = machineLearning.getRecommendations();

      const recommendationsList = document.getElementById('active-recommendations');
      if (recommendationsList) {
        if (recommendations.length === 0) {
          recommendationsList.innerHTML = `
            <div class="recommendation-item">
              <span class="recommendation-type">-</span>
              <span class="recommendation-item">-</span>
              <span class="recommendation-score">-</span>
            </div>
          `;
        } else {
          recommendationsList.innerHTML = recommendations.slice(-5).reverse().map(recommendation => `
            <div class="recommendation-item">
              <span class="recommendation-type">${recommendation.type}</span>
              <span class="recommendation-item">${recommendation.itemId}</span>
              <span class="recommendation-score">${(recommendation.score * 100).toFixed(1)}%</span>
            </div>
          `).join('');
        }
      }
    }

    private async updateAnomalies(): Promise<void> {
      const anomalies = machineLearning.getAnomalies();

      const anomaliesList = document.getElementById('recent-anomalies');
      if (anomaliesList) {
        if (anomalies.length === 0) {
          anomaliesList.innerHTML = `
            <div class="anomaly-item">
              <span class="anomaly-type">-</span>
              <span class="anomaly-severity">-</span>
              <span class="anomaly-status">-</span>
            </div>
          `;
        } else {
          anomaliesList.innerHTML = anomalies.slice(-5).reverse().map(anomaly => `
            <div class="anomaly-item">
              <span class="anomaly-type">${anomaly.type}</span>
              <span class="anomaly-severity ${anomaly.severity}">${anomaly.severity}</span>
              <span class="anomaly-status ${anomaly.status}">${anomaly.status}</span>
            </div>
          `).join('');
        }
      }
    }

    private async updateUserSegmentation(): Promise<void> {
      const segmentations = machineLearning.getUserSegmentations();

      const segmentsList = document.getElementById('user-segments');
      if (segmentsList) {
        if (segmentations.length === 0) {
          segmentsList.innerHTML = `
            <div class="segment-item">
              <span class="segment-name">-</span>
              <span class="segment-size">-</span>
              <span class="segment-percentage">-</span>
            </div>
          `;
        } else {
          const segments = segmentations[0]?.segments || [];
          segmentsList.innerHTML = segments.map(segment => `
            <div class="segment-item">
              <span class="segment-name">${segment.name}</span>
              <span class="segment-size">${segment.size.toLocaleString()}</span>
              <span class="segment-percentage">${segment.percentage}%</span>
            </div>
          `).join('');
        }
      }
    }

    private async updateSentimentAnalysis(): Promise<void> {
      const sentimentAnalyses = machineLearning.getSentimentAnalyses();

      // Calcular porcentajes de sentimiento
      const total = sentimentAnalyses.length;
      const positive = sentimentAnalyses.filter(s => s.sentiment === 'positive').length;
      const neutral = sentimentAnalyses.filter(s => s.sentiment === 'neutral').length;
      const negative = sentimentAnalyses.filter(s => s.sentiment === 'negative').length;

      const positivePercentage = total > 0 ? (positive / total) * 100 : 0;
      const neutralPercentage = total > 0 ? (neutral / total) * 100 : 0;
      const negativePercentage = total > 0 ? (negative / total) * 100 : 0;

      this.updateElement('positive-sentiment', `${positivePercentage.toFixed(1)}%`);
      this.updateElement('neutral-sentiment', `${neutralPercentage.toFixed(1)}%`);
      this.updateElement('negative-sentiment', `${negativePercentage.toFixed(1)}%`);
    }

    private async updateChurnPrediction(): Promise<void> {
      const churnPredictions = machineLearning.getChurnPredictions();

      // Calcular conteos por nivel de riesgo
      const lowRisk = churnPredictions.filter(p => p.riskLevel === 'low').length;
      const mediumRisk = churnPredictions.filter(p => p.riskLevel === 'medium').length;
      const highRisk = churnPredictions.filter(p => p.riskLevel === 'high').length;
      const criticalRisk = churnPredictions.filter(p => p.riskLevel === 'critical').length;

      this.updateElement('low-risk', lowRisk.toString());
      this.updateElement('medium-risk', mediumRisk.toString());
      this.updateElement('high-risk', highRisk.toString());
      this.updateElement('critical-risk', criticalRisk.toString());
    }

    private updateCharts(): void {
      // Actualizar gráficos con nuevos datos
      this.charts.forEach(chart => {
        if (chart.update) {
          chart.update({});
        }
      });
    }

    private updateElement(id: string, value: string): void {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = value;
      }
    }

    private toggleAutoTraining(enabled: boolean): void {
      console.log('Auto training toggled:', enabled);
    }

    private toggleRealtimePredictions(enabled: boolean): void {
      console.log('Realtime predictions toggled:', enabled);
    }

    private toggleRecommendations(enabled: boolean): void {
      console.log('Recommendations toggled:', enabled);
    }

    private toggleAnomalyDetection(enabled: boolean): void {
      console.log('Anomaly detection toggled:', enabled);
    }

    private toggleSentimentAnalysis(enabled: boolean): void {
      console.log('Sentiment analysis toggled:', enabled);
    }

    private toggleChurnPrediction(enabled: boolean): void {
      console.log('Churn prediction toggled:', enabled);
    }

    private async exportAIData(): Promise<void> {
      try {
        const data = {
          timestamp: new Date().toISOString(),
          models: machineLearning.getModels(),
          predictions: machineLearning.getPredictions(),
          recommendations: machineLearning.getRecommendations(),
          anomalies: machineLearning.getAnomalies(),
          segmentations: machineLearning.getUserSegmentations(),
          sentimentAnalyses: machineLearning.getSentimentAnalyses(),
          churnPredictions: machineLearning.getChurnPredictions(),
          config: machineLearning.getConfig(),
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `ai-data-${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('Error exporting AI data:', error);
      }
    }

    private openAISettings(): void {
      console.log('Opening AI settings...');
    }

    public destroy(): void {
      if (this.updateInterval) {
        clearInterval(this.updateInterval);
      }
    }
  }

  // Inicializar dashboard cuando el DOM esté listo
  document.addEventListener('DOMContentLoaded', () => {
    new AIDashboard();
  });
</script>

<style>
  .ai-dashboard {
    padding: 2rem;
    max-width: 1400px;
    margin: 0 auto;
  }

  .dashboard-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
  }

  .dashboard-controls {
    display: flex;
    gap: 1rem;
  }

  .dashboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
  }

  .metric-card {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--border-radius);
    padding: 1.5rem;
    box-shadow: var(--shadow-sm);
  }

  .metric-card h3 {
    margin: 0 0 1rem 0;
    color: var(--color-text-primary);
  }

  .chart-card {
    grid-column: span 2;
  }

  .models-list,
  .predictions-list,
  .recommendations-list,
  .anomalies-list,
  .segments-list {
    max-height: 300px;
    overflow-y: auto;
  }

  .model-item,
  .prediction-item,
  .recommendation-item,
  .anomaly-item,
  .segment-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    background: var(--color-surface-secondary);
    border-radius: var(--border-radius);
  }

  .model-name,
  .prediction-model,
  .recommendation-type,
  .anomaly-type,
  .segment-name {
    font-weight: 500;
    color: var(--color-text-primary);
  }

  .model-status,
  .anomaly-severity,
  .anomaly-status {
    font-size: 0.75rem;
    padding: 0.25rem 0.5rem;
    border-radius: var(--border-radius);
    color: white;
  }

  .model-status.ready,
  .model-status.deployed {
    background: var(--color-success);
  }

  .model-status.training {
    background: var(--color-warning);
  }

  .model-status.failed {
    background: var(--color-error);
  }

  .anomaly-severity.low {
    background: var(--color-info);
  }

  .anomaly-severity.medium {
    background: var(--color-warning);
  }

  .anomaly-severity.high {
    background: var(--color-error);
  }

  .anomaly-severity.critical {
    background: #8B0000;
  }

  .anomaly-status.new {
    background: var(--color-info);
  }

  .anomaly-status.investigating {
    background: var(--color-warning);
  }

  .anomaly-status.resolved {
    background: var(--color-success);
  }

  .anomaly-status.false_positive {
    background: var(--color-text-secondary);
  }

  .model-accuracy,
  .prediction-confidence,
  .recommendation-score,
  .segment-size,
  .segment-percentage {
    color: var(--color-text-secondary);
  }

  .sentiment-summary,
  .churn-summary {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .sentiment-item,
  .churn-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem;
    background: var(--color-surface-secondary);
    border-radius: var(--border-radius);
  }

  .sentiment-label,
  .churn-label {
    font-weight: 500;
    color: var(--color-text-primary);
  }

  .sentiment-percentage,
  .churn-count {
    font-weight: 600;
    color: var(--color-primary);
  }

  .ai-config {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
  }

  .config-item {
    display: flex;
    align-items: center;
  }

  .config-item label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    color: var(--color-text-primary);
  }

  .config-item input[type="checkbox"] {
    width: 1rem;
    height: 1rem;
  }

  @media (max-width: 768px) {
    .dashboard-grid {
      grid-template-columns: 1fr;
    }

    .chart-card {
      grid-column: span 1;
    }

    .ai-config {
      grid-template-columns: 1fr;
    }
  }
</style>
